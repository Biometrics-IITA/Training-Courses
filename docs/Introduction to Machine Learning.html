<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title> Introduction to Machine Learning </title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Introduction to Machine Learning_files/libs/clipboard/clipboard.min.js"></script>
<script src="Introduction to Machine Learning_files/libs/quarto-html/quarto.js"></script>
<script src="Introduction to Machine Learning_files/libs/quarto-html/popper.min.js"></script>
<script src="Introduction to Machine Learning_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Introduction to Machine Learning_files/libs/quarto-html/anchor.min.js"></script>
<link href="Introduction to Machine Learning_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Introduction to Machine Learning_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Introduction to Machine Learning_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Introduction to Machine Learning_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Introduction to Machine Learning_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="assets/rany_style.css">
</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Outline</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span style="color: #234F1E;"><strong>Introduction</strong></span></a>
  <ul class="collapse">
  <li><a href="#features-of-machine-learning" id="toc-features-of-machine-learning" class="nav-link" data-scroll-target="#features-of-machine-learning"><span style="color: #002D62;">Features of Machine Learning</span></a></li>
  <li><a href="#ml-the-jargon" id="toc-ml-the-jargon" class="nav-link" data-scroll-target="#ml-the-jargon"><span style="color: #002D62;">ML: The Jargon</span></a></li>
  </ul></li>
  <li><a href="#the-ml-workflow" id="toc-the-ml-workflow" class="nav-link" data-scroll-target="#the-ml-workflow"><span style="color: #2C6D26;"><strong>The ML workflow</strong></span></a></li>
  <li><a href="#data-pre-processing-in-ml" id="toc-data-pre-processing-in-ml" class="nav-link" data-scroll-target="#data-pre-processing-in-ml"><span style="color: #2C6D26;"><strong>Data Pre-processing in ML</strong></span></a></li>
  <li><a href="#categories-of-machine-learning" id="toc-categories-of-machine-learning" class="nav-link" data-scroll-target="#categories-of-machine-learning"><span style="color: #234F1E;"><strong>Categories of Machine Learning</strong></span></a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><p style="color:black,text-align:center"><br>
Introduction to Machine Learning<br>
</p></h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><font color="#ff6600"><b>Biometrics Unit</b></font> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            <font color="#ff6600"><b>International Institute of Tropical Agriculture (IITA)</b></font>
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1><span style="color: #234F1E;"><strong>Introduction</strong></span></h1>
<p>Artificial intelligence (<strong>AI</strong>) is a technology that equips machines with the ability to simulate human behavior, specifically cognitive processes.</p>
<p>Machine learning (<strong>ML</strong>) is a branch of <strong>AI</strong> that focuses on using data and algorithms to learn in the same way that humans do, gradually improving its accuracy. Machine learning algorithms develop a mathematical model that helps make predictions or decisions based on sample historical data, or training data, without needing explicit programming. By integrating statistics and computer science, machine learning facilitates the creation of predictive models.</p>
<p><img src="images/ML1.png" width="75%"></p>
<p><strong>ML</strong> models prioritize prediction accuracy and are very good at handling complex data, while <strong>classical statistical models</strong> focus on understanding relationships and making inferences. Nevertheless, both have their place in data science, depending on the problem and context.</p>
<p><strong>ML</strong> offers numerous benefits that increase agricultural efficiencies, improve crop yield, and reduce food cost of production. <strong>ML</strong> can identify patterns and trends in massive data that humans may miss entirely.</p>
<p>This analysis requires little human intervention: simply feed in the dataset of interest and allow the <strong>ML</strong> system to assemble and refine its algorithms which will continuously improve with more data input over time.</p>
<p>The drawback of <strong>ML</strong>, it requires large training datasets that are both accurate and unbiased. Gathering enough data and having a system that can handle it may also be a drain on resources. <strong>ML</strong> can also be error-prone, depending on the input. With too small a sample size, the system may generate a perfectly logical algorithm that is completely incorrect or misleading. <strong>ML</strong> is a powerful tool that transforms industries, however, it’s crucial to understand its potential and limitations.</p>
<section id="features-of-machine-learning" class="level2">
<h2 class="anchored" data-anchor-id="features-of-machine-learning"><span style="color: #002D62;">Features of Machine Learning</span></h2>
<ol type="1">
<li>Machine learning utilizes data to identify patterns within a dataset.</li>
<li>It learns from past data and improves autonomously over time.</li>
<li>As a data-driven technology, machine learning shares similarities with data mining, both of which involve working with large volumes of data.</li>
</ol>
</section>
<section id="ml-the-jargon" class="level2">
<h2 class="anchored" data-anchor-id="ml-the-jargon"><span style="color: #002D62;">ML: The Jargon</span></h2>
<p><img src="images/jargon.png" width="60%"></p>
<ul>
<li><p><strong>Instance:</strong> A single row (observation) of data is called an instance</p></li>
<li><p><strong>Feature:</strong> A single column (independent variable, attribute) is called a feature. The predictor is called <strong>Target</strong></p></li>
<li><p><strong>Data Type:</strong> Data can be quantitative (e.g., regression) or qualitative (e.g., classification)</p></li>
<li><p><strong>Training Dataset:</strong> A dataset to feed into our ML to train the model</p></li>
<li><p><strong>Testing Dataset:</strong> A new dataset to validate the accuracy of the model</p></li>
<li><p><strong>Data:</strong> Machine learning requires data to train the models. This data could be anything from images and text to numerical values and more.</p></li>
<li><p><strong>Algorithms:</strong> These are the methods or techniques used to analyze the data. Different algorithms are used depending on the task, such as classification, regression, clustering, etc.</p></li>
<li><p><strong>Training:</strong> This is the process where the algorithm learns from the data. During training, the algorithm adjusts its parameters to minimize errors and improve accuracy.</p></li>
<li><p><strong>Prediction/Inference:</strong> After training, the model can make predictions or decisions based on new, unseen data.</p></li>
<li><p><strong>Evaluation:</strong> The performance of the model is assessed using metrics like accuracy, precision, recall, etc., to ensure it meets the desired goals.</p></li>
</ul>
</section>
</section>
<section id="the-ml-workflow" class="level1">
<h1><span style="color: #2C6D26;"><strong>The ML workflow</strong></span></h1>
<ul>
<li><strong>STEP 0:</strong> Define the Problem and Collect/Gather the data that will be used to train the model</li>
<li><strong>STEP 1 - Data pre-processing:</strong>
<ul>
<li>Clean the dataset to handle missing values, incorrect data, and remove duplicates.</li>
<li>Perform exploratory data analysis (EDA) to understand the patterns, trends, and relationships within the data</li>
<li>Divide the data into training and test sets</li>
<li>Data transformation and normalization (training and test sets) to make it suitable for modeling.</li>
</ul></li>
<li><strong>STEP 2 - Train the Model:</strong>
<ul>
<li>Choose an ML model appropriate with the data (the target)</li>
<li>Cross-validation: Divide the training dataset into “k” subsets or “folds”. The model training and validation process is repeated “k” times, with each of the k folds used exactly once as the validation data, and the remaining k-1 folds used as training data</li>
<li>Tune the model (some ML): based on the performance metrics, adjust the model parameters. Hyperparameter tuning can be done manually or through automated methods like grid search or random search. For simplicity, we will not cover this and will accept the default parametrization.</li>
</ul></li>
<li><strong>STEP 3 - Evaluate the Model:</strong>
<ul>
<li>Assess the model’s performance using cross-validation results</li>
<li>Run the final model</li>
</ul></li>
<li><strong>STEP 4 - Test the Model:</strong> Once the model is fine-tuned, evaluate it on the test set to assess its performance.</li>
</ul>
<p><img src="images/ML4.png" width="70%"></p>
</section>
<section id="data-pre-processing-in-ml" class="level1">
<h1><span style="color: #2C6D26;"><strong>Data Pre-processing in ML</strong></span></h1>
<p>Once you import your dataset into R, data pre-processing is the next crucial stage. Data pre-processing, also known as data preparation, data wrangling, or feature engineering, involves several tasks:</p>
<ul>
<li><p><strong>Data Collection:</strong> Gather data from various sources.</p></li>
<li><p><strong>Data Cleaning:</strong> Identifying and correcting errors or inconsistencies in the data.</p></li>
<li><p><strong>Feature Selection:</strong> Choosing relevant input variables for the model.</p></li>
<li><p><strong>Data Transformation:</strong> Converting raw data into a suitable format for modeling.</p></li>
<li><p><strong>Feature Engineering:</strong> Creating new variables from existing data.</p></li>
<li><p><strong>Train-Test Split:</strong> Divide data into training and testing sets. There are two competing concerns:</p>
<ul>
<li>With less training data, your parameter estimates have greater variance.</li>
<li>With less testing data, your performance statistic will have greater variance.</li>
<li>We should be concerned with dividing data such that neither variance is too high: usually <strong>80%</strong> for training and <strong>20%</strong> for testing (Thump rule)</li>
</ul></li>
<li><p><strong>Scaling and Normalization:</strong> Ensure features are on a similar scale</p></li>
<li><p><strong>Dimensionality Reduction:</strong> Reducing the number of features while preserving information if needed.</p></li>
</ul>
<p>Accurate predictions depend on high-quality data. Hence, properly prepared data simplifies model training and improves real-time project performance.</p>
</section>
<section id="categories-of-machine-learning" class="level1">
<h1><span style="color: #234F1E;"><strong>Categories of Machine Learning</strong></span></h1>
<p>Various <strong>ML</strong> algorithms that are commonly used can be classified under two categories:</p>
<pre><code>1. Supervised learning
2. Unsupervised learning</code></pre>
<p>Each of these categories has their respective sub-categories. <img src="images/ML.png" width="70%"></p>
<p>insert-&gt;footnote</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>